<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Slayer File Loading Diagnostic</title>
        <style>
            body {
                font-family: monospace;
                padding: 20px;
                background: #1a1a1a;
                color: #0f0;
            }
            #drop-zone {
                border: 2px dashed #0f0;
                padding: 40px;
                text-align: center;
                margin: 20px 0;
                background: rgba(0, 255, 0, 0.05);
            }
            #drop-zone.dragover {
                background: rgba(0, 255, 0, 0.2);
            }
            .log-entry {
                margin: 5px 0;
                padding: 5px;
                background: rgba(0, 0, 0, 0.5);
                border-left: 3px solid #0f0;
            }
            .error {
                color: #f00;
                border-left-color: #f00;
            }
            .warning {
                color: #ff0;
                border-left-color: #ff0;
            }
            .success {
                color: #0f0;
                border-left-color: #0f0;
            }
            #canvas-container {
                margin: 20px 0;
                border: 1px solid #0f0;
                display: inline-block;
            }
            canvas {
                background: white;
                max-width: 800px;
            }
            .hidden {
                display: none;
            }
            pre {
                background: #000;
                padding: 10px;
                overflow-x: auto;
            }
        </style>
    </head>
    <body>
        <h1>üîç Slayer File Loading Diagnostic Tool</h1>

        <div id="drop-zone">
            Drop a .slayer file here or click to select
            <input type="file" id="file-input" accept=".slayer" style="display: none" />
        </div>

        <div id="logs"></div>

        <div id="canvas-container" class="hidden">
            <h3>PDF Preview:</h3>
            <canvas id="test-canvas"></canvas>
        </div>

        <div id="data-preview" class="hidden">
            <h3>Loaded Data:</h3>
            <pre id="data-content"></pre>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
        <script>
            pdfjsLib.GlobalWorkerOptions.workerSrc =
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

            const logs = document.getElementById('logs');
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const canvas = document.getElementById('test-canvas');
            const canvasContainer = document.getElementById('canvas-container');
            const dataPreview = document.getElementById('data-preview');
            const dataContent = document.getElementById('data-content');

            function log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logs.appendChild(entry);
                logs.scrollTop = logs.scrollHeight;
                console.log(message);
            }

            dropZone.addEventListener('click', () => fileInput.click());

            dropZone.addEventListener('dragover', e => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', async e => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) await analyzeSlayerFile(file);
            });

            fileInput.addEventListener('change', async e => {
                const file = e.target.files[0];
                if (file) await analyzeSlayerFile(file);
            });

            async function analyzeSlayerFile(file) {
                logs.innerHTML = '';
                canvasContainer.classList.add('hidden');
                dataPreview.classList.add('hidden');

                log(`üìÅ Loading file: ${file.name}`, 'info');
                log(`üìè File size: ${(file.size / 1024 / 1024).toFixed(2)} MB`, 'info');

                try {
                    const text = await file.text();
                    log(`‚úÖ File read successfully`, 'success');

                    const data = JSON.parse(text);
                    log(`‚úÖ JSON parsed successfully`, 'success');

                    // Check file type
                    if (data.type) {
                        log(`üìã File type: ${data.type}`, 'info');
                    }

                    // Check for apps
                    if (data.apps) {
                        log(`üì¶ Found apps structure`, 'success');
                        const appNames = Object.keys(data.apps);
                        log(`üì± Apps: ${appNames.join(', ')}`, 'info');

                        // Check for mapping_slayer
                        if (data.apps.mapping_slayer) {
                            log(`‚úÖ Found mapping_slayer data`, 'success');
                            const mappingData = data.apps.mapping_slayer;

                            // Log the structure to see what's there
                            const mappingKeys = Object.keys(mappingData);
                            log(`üîç mapping_slayer keys: ${mappingKeys.join(', ')}`, 'info');

                            // Check for appState (might be directly in mappingData or nested)
                            let appState = mappingData.appState;

                            // Check if it's in the old suite format (data.appState)
                            if (!appState && mappingData.data && mappingData.data.appState) {
                                appState = mappingData.data.appState;
                                log(
                                    `üîç Found appState in data.appState (old suite format)`,
                                    'info'
                                );
                            } else if (!appState && mappingData.data) {
                                appState = mappingData.data;
                                log(`üîç Using data directly`, 'info');
                            } else if (!appState) {
                                appState = mappingData;
                                log(`üîç Using mappingData directly`, 'info');
                            }

                            if (appState) {
                                log(`‚úÖ Found app data`, 'success');

                                // Check for PDF data
                                if (appState.sourcePdfBase64) {
                                    log(`‚úÖ Found sourcePdfBase64`, 'success');
                                    log(
                                        `üìè Base64 length: ${appState.sourcePdfBase64.length} characters`,
                                        'info'
                                    );

                                    // Try to decode and render the PDF
                                    await testPdfLoading(
                                        appState.sourcePdfBase64,
                                        appState.pdfFileName || appState.sourcePdfName
                                    );
                                } else {
                                    log(`‚ùå No sourcePdfBase64 found in appState`, 'error');
                                    log(
                                        `üîç Available appState keys: ${Object.keys(appState).join(', ')}`,
                                        'warning'
                                    );
                                }

                                // Check for dots
                                if (appState.dotsByPage) {
                                    const pageNumbers = Object.keys(appState.dotsByPage);
                                    log(`üìç Found dots for ${pageNumbers.length} pages`, 'info');

                                    let totalDots = 0;
                                    for (const pageNum of pageNumbers) {
                                        const pageData = appState.dotsByPage[pageNum];
                                        if (pageData.dots) {
                                            totalDots += pageData.dots.length;
                                            log(
                                                `  Page ${pageNum}: ${pageData.dots.length} dots`,
                                                'info'
                                            );
                                        }
                                    }
                                    log(`üìç Total dots: ${totalDots}`, 'success');
                                } else {
                                    log(`‚ö†Ô∏è No dotsByPage found`, 'warning');
                                }

                                // Check for marker types
                                if (appState.markerTypes) {
                                    const markerCodes = Object.keys(appState.markerTypes);
                                    log(
                                        `üè∑Ô∏è Found ${markerCodes.length} marker types: ${markerCodes.join(', ')}`,
                                        'info'
                                    );
                                } else {
                                    log(`‚ö†Ô∏è No markerTypes found`, 'warning');
                                }

                                // Show data preview
                                const preview = {
                                    hasBase64: !!appState.sourcePdfBase64,
                                    base64Length: appState.sourcePdfBase64?.length || 0,
                                    pdfFileName: appState.pdfFileName || appState.sourcePdfName,
                                    totalPages: appState.totalPages,
                                    currentPage: appState.currentPdfPage,
                                    markerTypes: Object.keys(appState.markerTypes || {}),
                                    dotPages: Object.keys(appState.dotsByPage || {})
                                };

                                dataContent.textContent = JSON.stringify(preview, null, 2);
                                dataPreview.classList.remove('hidden');
                            } else {
                                log(`‚ùå No appState found in mapping_slayer`, 'error');

                                // Check if data is at the root of mapping_slayer
                                if (mappingData.data) {
                                    log(`üîç Found 'data' property in mapping_slayer`, 'info');
                                    const actualData = mappingData.data;

                                    // Check for PDF in the data
                                    if (actualData.sourcePdfBase64) {
                                        log(`‚úÖ Found sourcePdfBase64 in data`, 'success');
                                        log(
                                            `üìè Base64 length: ${actualData.sourcePdfBase64.length} characters`,
                                            'info'
                                        );
                                        await testPdfLoading(
                                            actualData.sourcePdfBase64,
                                            actualData.pdfFileName || actualData.sourcePdfName
                                        );
                                    } else {
                                        log(`‚ùå No sourcePdfBase64 in data either`, 'error');
                                        log(
                                            `üîç data keys: ${Object.keys(actualData).slice(0, 10).join(', ')}...`,
                                            'info'
                                        );
                                    }
                                } else {
                                    // Check directly in mappingData
                                    if (mappingData.sourcePdfBase64) {
                                        log(
                                            `‚úÖ Found sourcePdfBase64 directly in mapping_slayer`,
                                            'success'
                                        );
                                        log(
                                            `üìè Base64 length: ${mappingData.sourcePdfBase64.length} characters`,
                                            'info'
                                        );
                                        await testPdfLoading(
                                            mappingData.sourcePdfBase64,
                                            mappingData.pdfFileName || mappingData.sourcePdfName
                                        );
                                    } else {
                                        log(
                                            `‚ùå No sourcePdfBase64 anywhere in mapping_slayer`,
                                            'error'
                                        );
                                    }
                                }
                            }
                        } else {
                            log(`‚ùå No mapping_slayer app found`, 'error');
                        }
                    } else {
                        log(`‚ö†Ô∏è No apps structure found - might be old format`, 'warning');
                    }
                } catch (error) {
                    log(`‚ùå Error: ${error.message}`, 'error');
                    console.error(error);
                }
            }

            async function testPdfLoading(base64Data, fileName) {
                log(`üîß Attempting to decode and render PDF...`, 'info');

                try {
                    // Decode base64
                    const binaryString = atob(base64Data);
                    log(`‚úÖ Base64 decoded, binary length: ${binaryString.length}`, 'success');

                    // Convert to Uint8Array
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    log(`‚úÖ Converted to Uint8Array`, 'success');

                    // Try to load with PDF.js
                    const loadingTask = pdfjsLib.getDocument({ data: bytes });
                    const pdfDoc = await loadingTask.promise;
                    log(`‚úÖ PDF loaded successfully! Pages: ${pdfDoc.numPages}`, 'success');

                    // Try to render first page
                    const page = await pdfDoc.getPage(1);
                    const viewport = page.getViewport({ scale: 0.5 });

                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    log(`‚úÖ PDF page 1 rendered successfully!`, 'success');
                    canvasContainer.classList.remove('hidden');
                } catch (error) {
                    log(`‚ùå PDF loading/rendering failed: ${error.message}`, 'error');
                    console.error(error);
                }
            }
        </script>
    </body>
</html>
