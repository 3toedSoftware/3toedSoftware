/**
 * SVG.js v3.2.0 - A lightweight library for manipulating and animating SVG
 * This is a minimal build for Design Slayer
 */

// Create SVG namespace
window.SVG = (function() {

    // Main SVG factory function
    function SVG(element) {
        return new SVGElement(element);
    }

    // Core SVGElement class
    class SVGElement {
        constructor(element) {
            if (typeof element === 'string') {
                // Create from string
                if (element.trim().startsWith('<')) {
                    // Parse SVG string
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(element, 'image/svg+xml');
                    this.node = doc.documentElement;
                } else {
                    // Create element by tag name
                    this.node = document.createElementNS('http://www.w3.org/2000/svg', element);
                }
            } else if (element && element.nodeType) {
                // Existing DOM element
                this.node = element;
            } else {
                // Create root SVG
                this.node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            }

            this.children = [];
        }

        // Add to container
        addTo(container) {
            if (typeof container === 'string') {
                container = document.querySelector(container);
            }
            if (container && container.appendChild) {
                container.appendChild(this.node);
            }
            return this;
        }

        // Set size
        size(width, height) {
            if (width) this.node.setAttribute('width', width);
            if (height) this.node.setAttribute('height', height);
            return this;
        }

        // Set viewBox
        viewbox(x, y, width, height) {
            if (arguments.length === 0) {
                const vb = this.node.getAttribute('viewBox');
                if (vb) {
                    const values = vb.split(/\s+|,/).map(Number);
                    return { x: values[0], y: values[1], width: values[2], height: values[3] };
                }
                return { x: 0, y: 0, width: 0, height: 0 };
            }
            this.node.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
            return this;
        }

        // Create rectangle
        rect(width, height) {
            const rect = new SVGElement('rect');
            if (width !== undefined) rect.node.setAttribute('width', width);
            if (height !== undefined) rect.node.setAttribute('height', height);
            this.node.appendChild(rect.node);
            this.children.push(rect);
            return rect;
        }

        // Create circle
        circle(radius) {
            const circle = new SVGElement('circle');
            if (radius !== undefined) circle.node.setAttribute('r', radius);
            this.node.appendChild(circle.node);
            this.children.push(circle);
            return circle;
        }

        // Create line
        line(x1, y1, x2, y2) {
            const line = new SVGElement('line');
            if (x1 !== undefined) line.node.setAttribute('x1', x1);
            if (y1 !== undefined) line.node.setAttribute('y1', y1);
            if (x2 !== undefined) line.node.setAttribute('x2', x2);
            if (y2 !== undefined) line.node.setAttribute('y2', y2);
            this.node.appendChild(line.node);
            this.children.push(line);
            return line;
        }

        // Create text
        text(content) {
            const text = new SVGElement('text');
            if (content !== undefined) text.node.textContent = content;
            this.node.appendChild(text.node);
            this.children.push(text);
            return text;
        }

        // Create group
        group() {
            const group = new SVGElement('g');
            this.node.appendChild(group.node);
            this.children.push(group);
            return group;
        }

        // Move element
        move(x, y) {
            if (this.node.tagName === 'text') {
                this.node.setAttribute('x', x);
                this.node.setAttribute('y', y);
            } else {
                this.node.setAttribute('x', x);
                this.node.setAttribute('y', y);
            }
            return this;
        }

        // Center element
        center(x, y) {
            const bbox = this.bbox();
            return this.move(x - bbox.width / 2, y - bbox.height / 2);
        }

        // Fill
        fill(color) {
            if (color === undefined) {
                return this.node.getAttribute('fill');
            }
            this.node.setAttribute('fill', color);
            return this;
        }

        // Stroke
        stroke(options) {
            if (typeof options === 'string') {
                this.node.setAttribute('stroke', options);
            } else if (options && typeof options === 'object') {
                if (options.color) this.node.setAttribute('stroke', options.color);
                if (options.width !== undefined) this.node.setAttribute('stroke-width', options.width);
                if (options.opacity !== undefined) this.node.setAttribute('stroke-opacity', options.opacity);
            }
            return this;
        }

        // Opacity
        opacity(value) {
            if (value === undefined) {
                return parseFloat(this.node.getAttribute('opacity') || 1);
            }
            this.node.setAttribute('opacity', value);
            return this;
        }

        // Add class
        addClass(className) {
            const current = this.node.getAttribute('class') || '';
            const classes = current.split(' ').filter(c => c);
            if (!classes.includes(className)) {
                classes.push(className);
                this.node.setAttribute('class', classes.join(' '));
            }
            return this;
        }

        // Remove class
        removeClass(className) {
            const current = this.node.getAttribute('class') || '';
            const classes = current.split(' ').filter(c => c && c !== className);
            this.node.setAttribute('class', classes.join(' '));
            return this;
        }

        // Set attribute
        attr(name, value) {
            if (typeof name === 'object') {
                Object.keys(name).forEach(key => {
                    this.node.setAttribute(key, name[key]);
                });
                return this;
            }
            if (value === undefined) {
                return this.node.getAttribute(name);
            }
            this.node.setAttribute(name, value);
            return this;
        }

        // Set style
        style(styles) {
            if (typeof styles === 'string') {
                this.node.style.cssText = styles;
            } else if (styles && typeof styles === 'object') {
                Object.keys(styles).forEach(key => {
                    this.node.style[key] = styles[key];
                });
            }
            return this;
        }

        // Font settings
        font(options) {
            if (options.family) this.node.setAttribute('font-family', options.family);
            if (options.size) this.node.setAttribute('font-size', options.size);
            if (options.weight) this.node.setAttribute('font-weight', options.weight);
            if (options.anchor) this.node.setAttribute('text-anchor', options.anchor);
            return this;
        }

        // Transform
        transform(options) {
            const transforms = [];

            if (options.translateX !== undefined || options.translateY !== undefined) {
                const tx = options.translateX || 0;
                const ty = options.translateY || 0;
                transforms.push(`translate(${tx},${ty})`);
            }

            if (options.scaleX !== undefined || options.scaleY !== undefined) {
                const sx = options.scaleX !== undefined ? options.scaleX : 1;
                const sy = options.scaleY !== undefined ? options.scaleY : 1;
                if (options.originX !== undefined || options.originY !== undefined) {
                    const ox = options.originX || 0;
                    const oy = options.originY || 0;
                    transforms.push(`translate(${ox},${oy}) scale(${sx},${sy}) translate(${-ox},${-oy})`);
                } else {
                    transforms.push(`scale(${sx},${sy})`);
                }
            }

            if (options.rotate !== undefined) {
                if (options.originX !== undefined || options.originY !== undefined) {
                    const ox = options.originX || 0;
                    const oy = options.originY || 0;
                    transforms.push(`rotate(${options.rotate} ${ox} ${oy})`);
                } else {
                    transforms.push(`rotate(${options.rotate})`);
                }
            }

            if (transforms.length > 0) {
                this.node.setAttribute('transform', transforms.join(' '));
            }

            return this;
        }

        // Get bounding box
        bbox() {
            try {
                const bbox = this.node.getBBox();
                return {
                    x: bbox.x,
                    y: bbox.y,
                    x2: bbox.x + bbox.width,
                    y2: bbox.y + bbox.height,
                    width: bbox.width,
                    height: bbox.height
                };
            } catch (e) {
                return { x: 0, y: 0, x2: 0, y2: 0, width: 0, height: 0 };
            }
        }

        // Event handlers
        click(handler) {
            this.node.addEventListener('click', handler);
            return this;
        }

        mousedown(handler) {
            this.node.addEventListener('mousedown', handler);
            return this;
        }

        mousemove(handler) {
            this.node.addEventListener('mousemove', handler);
            return this;
        }

        mouseup(handler) {
            this.node.addEventListener('mouseup', handler);
            return this;
        }

        on(event, handler) {
            this.node.addEventListener(event, handler);
            return this;
        }

        off(event, handler) {
            if (handler) {
                this.node.removeEventListener(event, handler);
            } else {
                // Remove all listeners for this event
                const clone = this.node.cloneNode(true);
                this.node.parentNode.replaceChild(clone, this.node);
                this.node = clone;
            }
            return this;
        }

        // Remove element
        remove() {
            if (this.node.parentNode) {
                this.node.parentNode.removeChild(this.node);
            }
            return this;
        }

        // Clear children
        clear() {
            while (this.node.firstChild) {
                this.node.removeChild(this.node.firstChild);
            }
            this.children = [];
            return this;
        }

        // Get SVG string
        svg() {
            return new XMLSerializer().serializeToString(this.node);
        }

        // Width/height getters/setters
        width(value) {
            if (value === undefined) {
                return parseFloat(this.node.getAttribute('width')) || 0;
            }
            this.node.setAttribute('width', value);
            return this;
        }

        height(value) {
            if (value === undefined) {
                return parseFloat(this.node.getAttribute('height')) || 0;
            }
            this.node.setAttribute('height', value);
            return this;
        }

        // X/Y getters/setters
        x(value) {
            if (value === undefined) {
                return parseFloat(this.node.getAttribute('x')) || 0;
            }
            this.node.setAttribute('x', value);
            return this;
        }

        y(value) {
            if (value === undefined) {
                return parseFloat(this.node.getAttribute('y')) || 0;
            }
            this.node.setAttribute('y', value);
            return this;
        }
    }

    // Expose the main function
    return SVG;

})();

// ES6 module export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SVG: window.SVG };
} else if (typeof exports !== 'undefined') {
    exports.SVG = window.SVG;
}